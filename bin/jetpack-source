#!/bin/bash
#
# Downloads and extracts the source code for one or more Jetpack packages.
#

usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] PACKAGE... [VERSION] [REPO_URL]

Download and extract source code for one or more Jetpack packages.

Arguments:
  PACKAGE     One or more package names in the format GROUP_ID:ARTIFACT_ID
              (supports brace expansion, e.g., androidx.pkg:{foo,bar})
  VERSION     Version string: ALPHA, BETA, RC, STABLE, LATEST, SNAPSHOT,
              or a specific version number (optional, defaults to STABLE)
  REPO_URL    Maven repository URL
              (optional, default: https://dl.google.com/android/maven2)
              For SNAPSHOT, this is ignored and the androidx.dev snapshot
              repo is used.

**About SNAPSHOT builds:** These are bleeding-edge versions of Jetpack
libraries. In these scripts, 'SNAPSHOT' always refers to the **latest**
available build from androidx.dev. Selecting a specific build ID is not
supported. Use this when you need the absolute latest, unreleased code.
More info: https://androidx.dev/

Options:
  -h, --help  Display this help message and exit
  --output DIR  Specify output directory (default: create temporary directory)

Examples:
  $(basename "$0") androidx.wear.tiles:tiles
  $(basename "$0") androidx.wear.tiles:tiles STABLE
  $(basename "$0") androidx.wear.tiles:tiles ALPHA
  $(basename "$0") androidx.wear.tiles:tiles RC
  $(basename "$0") androidx.wear.tiles:tiles SNAPSHOT
  $(basename "$0") androidx.glance:glance-wear-tiles SNAPSHOT
  $(basename "$0") androidx.wear.protolayout:protolayout-{expression,material,material3}
  $(basename "$0") com.google.android.horologist:horologist-datalayer \
    STABLE https://repo1.maven.org/maven2
  $(basename "$0") --output /tmp/wear-tiles androidx.wear.tiles:tiles BETA
  pushd "\$($(basename "$0") androidx.wear.tiles:tiles)"

The script creates a temporary directory, downloads the source JARs for the specified
packages, extracts them, and prints the path to the temporary directory.

For Kotlin Multiplatform libraries, the script automatically detects and downloads
platform-specific sources (e.g., -jvm, -android variants) in addition to common sources,
ensuring complete source code coverage for all platforms.
EOF
  exit 0
}

set -e

OUTPUT_DIR=""
REMAINING_ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      usage
      ;;
    --output)
      if [ -z "$2" ]; then
        echo "$(basename "$0"): option '--output' requires an argument" >&2
        exit 1
      fi
      OUTPUT_DIR="$2"
      shift 2
      ;;
    *)
      REMAINING_ARGS+=("$1")
      shift
      ;;
  esac
done
set -- "${REMAINING_ARGS[@]}" # Overwrite the original positional arguments

if [ "$#" -lt 1 ]; then
  usage
fi

require() {
  hash "$@" || {
    echo "Error: Command '$1' not found." >&2
    exit 127
  }
}

require curl
require jar
require jetpack-version

# Parse arguments: PACKAGE... [VERSION] [REPO_URL]
# Last argument is a URL -> it's REPO_URL
# Last non-URL argument doesn't contain ':' -> it's VERSION
# Arguments with ':' are PACKAGES
if [[ "${!#}" =~ ^https?:// ]]; then
  REPO_URL="${!#}"
  LAST_NON_URL_ARG="${*: -2:1}"
  if [[ ! "$LAST_NON_URL_ARG" =~ : ]]; then
    VERSION_STRING="$LAST_NON_URL_ARG"
    PACKAGES=("${@:1:$#-2}")
  else
    VERSION_STRING="STABLE"
    PACKAGES=("${@:1:$#-1}")
  fi
else
  REPO_URL="https://dl.google.com/android/maven2"
  LAST_ARG="${!#}"
  if [[ ! "$LAST_ARG" =~ : ]]; then
    VERSION_STRING="$LAST_ARG"
    PACKAGES=("${@:1:$#-1}")
  else
    VERSION_STRING="STABLE"
    PACKAGES=("$@")
  fi
fi

VERSION_STRING_UPPER=$(echo "$VERSION_STRING" | tr '[:lower:]' '[:upper:]')

# Check that at least one package was specified
if [ "${#PACKAGES[@]}" -eq 0 ]; then
  echo "$(basename "$0"): no packages specified (did you mean to include a package name with GROUP_ID:ARTIFACT_ID?)" >&2
  exit 1
fi

# For SNAPSHOT versions, set up the snapshot repository
if [ "$VERSION_STRING_UPPER" = "SNAPSHOT" ]; then
  # Use the "latest" redirect URL which automatically resolves to the current snapshot build
  # e.g., https://androidx.dev/snapshots/latest/artifacts/repository redirects to
  #       https://androidx.dev/snapshots/builds/14566697/artifacts/repository
  REPO_URL="https://androidx.dev/snapshots/latest/artifacts/repository"
  echo "info: Using AndroidX snapshot repository" >&2
fi

# Validate all packages before creating directories or downloading
for PACKAGE_NAME in "${PACKAGES[@]}"; do
  # Validate package name format
  if [[ ! "$PACKAGE_NAME" =~ ^[^:]+:[^:]+$ ]]; then
    echo "$(basename "$0"): invalid package format '$PACKAGE_NAME' (expected GROUP_ID:ARTIFACT_ID)" >&2
    exit 1
  fi

  # Validate that package exists by checking maven-metadata.xml
  GROUP_ID=$(echo "$PACKAGE_NAME" | cut -d: -f1)
  ARTIFACT_ID=$(echo "$PACKAGE_NAME" | cut -d: -f2)
  GROUP_ID_PATH=$(echo "$GROUP_ID" | sed 's/\./\//g')
  METADATA_URL="${REPO_URL}/${GROUP_ID_PATH}/${ARTIFACT_ID}/maven-metadata.xml"

  if ! curl -sSLf "$METADATA_URL" >/dev/null 2>&1; then
    echo "$(basename "$0"): failed to fetch $METADATA_URL" >&2
    exit 1
  fi
done

# Create output directory
if [ -n "$OUTPUT_DIR" ]; then
  BUILD_DIR="$OUTPUT_DIR"
  mkdir -p "$BUILD_DIR"
else
  BUILD_DIR=$(mktemp -d "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX")
fi

# Download and extract each package
for PACKAGE_NAME in "${PACKAGES[@]}"; do
  GROUP_ID=$(echo "$PACKAGE_NAME" | cut -d: -f1)
  ARTIFACT_ID=$(echo "$PACKAGE_NAME" | cut -d: -f2)
  GROUP_ID_PATH=$(echo "$GROUP_ID" | sed 's/\./\//g')

  # Resolve version (use the first package to resolve ALPHA/BETA/RC/STABLE/LATEST/SNAPSHOT)
  if [ -z "$VERSION" ]; then
    if [ "$VERSION_STRING_UPPER" == "ALPHA" ] || [ "$VERSION_STRING_UPPER" == "BETA" ] || [ "$VERSION_STRING_UPPER" == "RC" ] || [ "$VERSION_STRING_UPPER" == "STABLE" ] || [ "$VERSION_STRING_UPPER" == "LATEST" ] || [ "$VERSION_STRING_UPPER" == "SNAPSHOT" ]; then
      VERSION=$(jetpack-version "${PACKAGE_NAME}" "$VERSION_STRING_UPPER" "$REPO_URL")
      echo "info: Resolved $VERSION_STRING_UPPER version for ${PACKAGE_NAME} to ${VERSION}" >&2
    else
      VERSION=$VERSION_STRING
    fi
  fi

  # For SNAPSHOT versions, we need to resolve the timestamped version for the JAR filename
  # The directory structure uses X.Y.Z-SNAPSHOT but the JAR uses X.Y.Z-TIMESTAMP-N
  JAR_VERSION="$VERSION"
  if [[ "$VERSION" =~ -SNAPSHOT$ ]]; then
    # Fetch the version-specific maven-metadata.xml to get the timestamped version
    VERSION_METADATA_URL="${REPO_URL}/${GROUP_ID_PATH}/${ARTIFACT_ID}/${VERSION}/maven-metadata.xml"
    SNAPSHOT_JAR_VERSION=$(curl -sSLf "$VERSION_METADATA_URL" 2>/dev/null |
      xmllint --xpath "//snapshotVersion[classifier='sources' and extension='jar']/value/text()" - 2>/dev/null || true)

    if [ -n "$SNAPSHOT_JAR_VERSION" ]; then
      JAR_VERSION="$SNAPSHOT_JAR_VERSION"
      echo "info: Resolved snapshot JAR version to ${JAR_VERSION}" >&2
    else
      echo "$(basename "$0"): warning: could not resolve timestamped version, trying ${VERSION}" >&2
    fi
  fi

  SOURCE_JAR_URL="${REPO_URL}/${GROUP_ID_PATH}/${ARTIFACT_ID}/${VERSION}/${ARTIFACT_ID}-${JAR_VERSION}-sources.jar"
  SOURCE_JAR_FILENAME="${ARTIFACT_ID}-${JAR_VERSION}-sources.jar"

  echo "info: Downloading ${PACKAGE_NAME} version ${VERSION}" >&2
  if ! curl -sSLf -o "${BUILD_DIR}/${SOURCE_JAR_FILENAME}" "${SOURCE_JAR_URL}"; then
    echo "$(basename "$0"): failed to download $SOURCE_JAR_URL" >&2
    exit 1
  fi

  (
    cd "${BUILD_DIR}"
    jar xf "${SOURCE_JAR_FILENAME}"
    rm "${SOURCE_JAR_FILENAME}"
  )

  # Check for Kotlin Multiplatform platform-specific sources
  # Download the POM to check for platform dependencies (-jvm, -android, etc.)
  POM_URL="${REPO_URL}/${GROUP_ID_PATH}/${ARTIFACT_ID}/${VERSION}/${ARTIFACT_ID}-${JAR_VERSION}.pom"
  POM_CONTENT=$(curl -sSLf "${POM_URL}" 2>/dev/null || true)

  if [ -n "$POM_CONTENT" ]; then
    # Look for dependencies on platform-specific artifacts (e.g., artifact-jvm, artifact-android)
    # Extract artifact IDs that match the pattern: ${ARTIFACT_ID}-{platform}
    # Use local-name() to handle XML namespaces
    PLATFORM_ARTIFACTS=$(echo "$POM_CONTENT" | xmllint --xpath "//*[local-name()='dependency']/*[local-name()='groupId' and text()='${GROUP_ID}']/../*[local-name()='artifactId']/text()" - 2>/dev/null | grep "^${ARTIFACT_ID}-" || true)

    if [ -n "$PLATFORM_ARTIFACTS" ]; then
      echo "info: Detected Kotlin Multiplatform library, downloading platform-specific sources..." >&2
      for PLATFORM_ARTIFACT in $PLATFORM_ARTIFACTS; do
        # For SNAPSHOT versions, resolve the timestamped version for each platform artifact
        PLATFORM_JAR_VERSION="$VERSION"
        if [[ "$VERSION" =~ -SNAPSHOT$ ]]; then
          PLATFORM_VERSION_METADATA_URL="${REPO_URL}/${GROUP_ID_PATH}/${PLATFORM_ARTIFACT}/${VERSION}/maven-metadata.xml"
          PLATFORM_SNAPSHOT_JAR_VERSION=$(curl -sSLf "$PLATFORM_VERSION_METADATA_URL" 2>/dev/null |
            xmllint --xpath "//snapshotVersion[classifier='sources' and extension='jar']/value/text()" - 2>/dev/null || true)
          if [ -n "$PLATFORM_SNAPSHOT_JAR_VERSION" ]; then
            PLATFORM_JAR_VERSION="$PLATFORM_SNAPSHOT_JAR_VERSION"
          fi
        fi

        PLATFORM_SOURCE_JAR_URL="${REPO_URL}/${GROUP_ID_PATH}/${PLATFORM_ARTIFACT}/${VERSION}/${PLATFORM_ARTIFACT}-${PLATFORM_JAR_VERSION}-sources.jar"
        PLATFORM_SOURCE_JAR_FILENAME="${PLATFORM_ARTIFACT}-${PLATFORM_JAR_VERSION}-sources.jar"

        # Try to download platform sources (may not exist for all platforms)
        if curl -sSLf -o "${BUILD_DIR}/${PLATFORM_SOURCE_JAR_FILENAME}" "${PLATFORM_SOURCE_JAR_URL}" 2>/dev/null; then
          echo "info: Downloaded ${PLATFORM_ARTIFACT} platform sources" >&2
          (
            cd "${BUILD_DIR}"
            jar xf "${PLATFORM_SOURCE_JAR_FILENAME}"
            rm "${PLATFORM_SOURCE_JAR_FILENAME}"
          )
        fi
      done
    fi
  fi
done

# Clean up META-INF after all extractions
rm -rf "${BUILD_DIR}/META-INF"

echo "${BUILD_DIR}"
