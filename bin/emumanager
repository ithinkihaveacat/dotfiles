#!/usr/bin/env bash
set -euo pipefail

# See https://developer.android.com/tools/variables#envar
export ANDROID_HOME="${ANDROID_HOME:-$HOME/.local/share/android-sdk}"
export ANDROID_USER_HOME="${ANDROID_USER_HOME:-$HOME/.android}"

# IMPORTANT: All Android SDK tools (adb, emulator, avdmanager, sdkmanager, etc.)
# must be invoked using their full paths within $ANDROID_HOME, NOT from system PATH.
# This ensures we use the correct versions and avoid conflicts with system-installed
# Android tools. The require() function allows these commands to be satisfied from
# $ANDROID_HOME paths.
#
# For emulator command-line reference, see:
# https://developer.android.com/studio/run/emulator-commandline

# To find valid versions for build-tools, run:
# sdkmanager --list | grep "build-tools;"
export ANDROID_BUILD_TOOLS_VERSION="36.0.0"
# To find valid versions for platforms, run:
# sdkmanager --list | grep "platforms;android-"
export ANDROID_PLATFORM_VERSION="android-36"

# Blocklist of known problematic system images that should be excluded
# from automatic "latest" image selection. Add full package names here.
# These images have known issues (e.g., HVF compatibility problems on macOS).
BLOCKLISTED_IMAGES=(
  "system-images;android-36.1;google_apis_playstore;arm64-v8a"
)

get_host_arch() {
  case "$(uname -m)" in
    arm64 | aarch64)
      echo "arm64-v8a"
      ;;
    x86_64)
      # Android SDK uses "x8664" not "x86_64" (no underscore)
      echo "x8664"
      ;;
    *)
      echo "$(basename "$0"): Unsupported architecture: $(uname -m)" >&2
      exit 1
      ;;
  esac
}

# Check if a version string is a valid numeric version
# Valid: "36", "36.1", "35"
# Invalid: "CANARY", "Baklava", "36.0-Baklava", "35-ext15"
# Returns 0 (success) if valid, 1 (failure) if invalid
is_numeric_version() {
  local version_string="$1"
  [[ "$version_string" =~ ^[0-9]+(\.[0-9]+)?$ ]]
}

get_default_image_package() {
  # Default to mobile/phone device type
  get_latest_image_for_type "mobile"
}

# Get the latest available image for a specific device type
# Usage: get_latest_image_for_type <device_type>
# Device types: mobile, wear, tv, auto
get_latest_image_for_type() {
  local device_type="$1"
  local arch
  arch=$(get_host_arch)

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
  if [[ ! -f "$sdkmanager" ]]; then
    echo "$(basename "$0"): sdkmanager not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  # Get all available packages
  local all_packages
  if ! all_packages=$(timeout 120 "$sdkmanager" --list 2>&1); then
    echo "$(basename "$0"): Failed to list available packages" >&2
    exit 1
  fi

  # Define patterns for each device type
  # This design allows for easy addition of new device types in the future
  local tag_patterns
  local exclude_patterns
  local prefer_pattern=""

  case "$device_type" in
    mobile)
      # Prefer google_apis_playstore for Google Play support
      # Also accept google_apis as fallback
      # Exclude specialized variants (wear, tv, automotive, desktop, tablet, xr, atd, ps16k)
      tag_patterns="google_apis_playstore|google_apis"
      exclude_patterns="wear|tv|automotive|desktop|tablet|xr|atd|ps16k"
      prefer_pattern="google_apis_playstore"
      ;;
    wear)
      # Accept both signed and unsigned Wear OS images
      tag_patterns="android-wear-signed|android-wear"
      exclude_patterns="cn" # Exclude China-specific variants
      prefer_pattern="android-wear-signed"
      ;;
    tv)
      # Android TV / Google TV devices
      tag_patterns="android-tv|google-tv"
      exclude_patterns=""
      prefer_pattern="google-tv"
      ;;
    auto)
      # Android Automotive devices
      tag_patterns="android-automotive-playstore|android-automotive"
      exclude_patterns="distant-display" # Exclude distant display variants
      prefer_pattern="android-automotive-playstore"
      ;;
    *)
      echo "$(basename "$0"): Unknown device type: $device_type" >&2
      echo "Supported types: mobile, wear, tv, auto" >&2
      exit 1
      ;;
  esac

  # Find matching images and extract the one with the highest API level
  # Only consider numeric versions (e.g., 35, 36, 36.1)
  # Skip CANARY and letter codename versions (e.g., Baklava)
  local best_image=""
  local best_major=0
  local best_minor=0
  local preferred_image=""
  local preferred_major=0
  local preferred_minor=0

  while IFS= read -r line; do
    # Extract package path
    local package
    package=$(echo "$line" | awk -F'|' '{print $1}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # Skip if not a system-image for our architecture
    # Architecture must be the last field in the package path
    if [[ ! "$package" =~ \;${arch}$ ]]; then
      continue
    fi

    # Check if it matches our tag patterns
    if ! echo "$package" | grep -qE ";(${tag_patterns});" 2>/dev/null; then
      continue
    fi

    # Check if it should be excluded
    if [[ -n "$exclude_patterns" ]] && echo "$package" | grep -qE "$exclude_patterns" 2>/dev/null; then
      continue
    fi

    # Check if package is in the blocklist
    local is_blocklisted=false
    for blocklisted in "${BLOCKLISTED_IMAGES[@]}"; do
      if [[ "$package" == "$blocklisted" ]]; then
        is_blocklisted=true
        break
      fi
    done
    if [[ "$is_blocklisted" == "true" ]]; then
      continue
    fi

    # Extract API level/version (second field in package path)
    local api_part
    api_part=$(echo "$package" | awk -F';' '{print $2}')
    local version_string
    version_string="${api_part#android-}"

    # Only accept numeric versions (with optional decimal point)
    # Skip CANARY, letter codenames (Baklava), and versions with suffixes (36.0-Baklava)
    if ! is_numeric_version "$version_string"; then
      continue
    fi

    # Parse major and minor version
    # Use IFS and read to reliably split on dot
    local major minor
    IFS='.' read -r major minor <<<"$version_string"
    # If no minor version exists (no decimal point), default to 0
    minor=${minor:-0}

    # Compare versions: prefer higher major, then higher minor
    local is_better=false
    if [[ $major -gt $best_major ]] ||
      [[ $major -eq $best_major && $minor -gt $best_minor ]]; then
      is_better=true
    fi

    # Update best if this is better
    if [[ "$is_better" == "true" ]]; then
      best_major=$major
      best_minor=$minor
      best_image="$package"
    fi

    # Track preferred variant separately (same comparison logic)
    if [[ -n "$prefer_pattern" ]] && echo "$package" | grep -qE "$prefer_pattern" 2>/dev/null; then
      local is_preferred_better=false
      if [[ $major -gt $preferred_major ]] ||
        [[ $major -eq $preferred_major && $minor -gt $preferred_minor ]]; then
        is_preferred_better=true
      fi

      if [[ "$is_preferred_better" == "true" ]]; then
        preferred_major=$major
        preferred_minor=$minor
        preferred_image="$package"
      fi
    fi
  done < <(echo "$all_packages" | grep "system-images;android-" || true)

  # Prefer the preferred variant if available, otherwise use best
  local selected_image=""
  if [[ -n "$preferred_image" ]]; then
    selected_image="$preferred_image"
  elif [[ -n "$best_image" ]]; then
    selected_image="$best_image"
  fi

  if [[ -z "$selected_image" ]]; then
    echo "$(basename "$0"): No suitable $device_type image found for architecture $arch" >&2
    echo "Try running: $(basename "$0") images" >&2
    exit 1
  fi

  echo "$selected_image"
}

usage() {
  local exit_code="${1:-0}"
  cat <<EOF
Usage: $(basename "$0") [COMMAND]

A script to set up and manage the Android SDK, emulator, and system images.

Environment:
  ANDROID_HOME: ${ANDROID_HOME}

Commands:
  bootstrap           Bootstrap SDK environment for emulator management.
  doctor              Run diagnostics to check for common issues.
  list                List all available AVDs.
  info <name>         Show detailed information about an AVD.
  create <name> [options] [image]
                      Create a new AVD with the specified device type or image.
                      Device type options:
                        --mobile, --phone    Create mobile/phone device (latest API)
                        --wear, --watch      Create Wear OS device (latest API)
                        --tv                 Create Android/Google TV device (latest API)
                        --auto               Create Android Automotive device (latest API)
                      If no device type or image is specified, defaults to mobile/phone.
                      If a specific image is provided, it overrides device type.
  start <name> [--cold-boot|--wipe-data]
                      Start the specified AVD.
                      --cold-boot: Perform a cold boot (bypass Quick Boot snapshots)
                      --wipe-data: Factory reset (wipe all data and perform cold boot)
  stop <name>         Stop the specified AVD.
  delete <name>       Delete the specified AVD.
  download <image>    Download a system image.
  images              List all available system images with API level >=33.
  outdated            Show outdated SDK packages.
  update              Update all installed SDK packages to latest versions.

Options:
  -h, --help          Display this help message and exit

Examples:
  # Create a mobile/phone AVD with the latest available image
  $(basename "$0") create my_phone --mobile

  # Create a Wear OS AVD with the latest available image
  $(basename "$0") create my_watch --wear

  # Create an Android/Google TV AVD with the latest available image
  $(basename "$0") create my_tv --tv

  # Create an Android Automotive AVD with the latest available image
  $(basename "$0") create my_car --auto

  # Create a new AVD with the default image (mobile/phone)
  $(basename "$0") create my_default_avd

  # Create a new AVD with a specific image
  $(basename "$0") create my_specific_avd "system-images;android-33;android-wear;x86_64"

  # Show information about an AVD
  $(basename "$0") info my_default_avd

  # Start an AVD (Quick Boot - fast)
  $(basename "$0") start my_default_avd

  # Start an AVD with a cold boot
  $(basename "$0") start my_default_avd --cold-boot

  # Factory reset an AVD (wipe all data)
  $(basename "$0") start my_default_avd --wipe-data

  # Check for outdated packages
  $(basename "$0") outdated
EOF
  exit "$exit_code"
}

require() {
  for cmd in "$@"; do
    if ! command -v "$cmd" &>/dev/null; then
      # If the command is in our SDK, let's try to find it there
      if [[ -f "$ANDROID_HOME/cmdline-tools/latest/bin/$cmd" || -f "$ANDROID_HOME/emulator/$cmd" || -f "$ANDROID_HOME/platform-tools/$cmd" ]]; then
        continue
      fi
      echo "$(basename "$0"): '$cmd' command not found" >&2
      exit 127
    fi
  done
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  usage
fi

if [[ -z "${1:-}" ]]; then
  usage
fi

install_cli_tools() {

  # Check if Android SDK cmdline-tools directory already exists
  if [[ -d "$ANDROID_HOME/cmdline-tools" ]]; then
    return 0
  fi

  local temp_dir
  temp_dir=$(mktemp -d)
  trap 'rm -rf -- "$temp_dir"' EXIT

  local os
  case "$(uname -s)" in
    Darwin)
      os="mac"
      ;;
    Linux)
      os="linux"
      ;;
    *)
      echo "$(basename "$0"): Unsupported OS: $(uname -s)" >&2
      exit 1
      ;;
  esac

  local repository_xml
  echo "Fetching repository metadata..."
  if ! repository_xml=$(curl -fsSL --connect-timeout 30 --max-time 60 https://dl.google.com/android/repository/repository2-1.xml); then
    echo "$(basename "$0"): Failed to fetch repository metadata" >&2
    echo "For manual installation: https://developer.android.com/studio#command-line-tools-only" >&2
    exit 1
  fi

  if [[ -z "${repository_xml}" ]]; then
    echo "$(basename "$0"): Repository metadata is empty" >&2
    echo "For manual installation: https://developer.android.com/studio#command-line-tools-only" >&2
    exit 1
  fi

  local latest_zip
  latest_zip=$(echo "${repository_xml}" | grep "commandlinetools-${os}" | head -n 1 | sed -e 's/.*>\(.*\).zip<\/url>.*/\1.zip/' || true)

  if [[ -z "${latest_zip}" || "${latest_zip}" == ".zip" ]]; then
    echo "$(basename "$0"): Could not parse command-line tools URL for ${os}" >&2
    echo "For manual installation: https://developer.android.com/studio#command-line-tools-only" >&2
    exit 1
  fi

  local download_url
  download_url="https://dl.google.com/android/repository/${latest_zip}"
  echo "Downloading ${download_url}..."
  if ! curl -fL --connect-timeout 30 --max-time 300 "${download_url}" -o "${temp_dir}/commandlinetools.zip"; then
    echo "$(basename "$0"): Failed to download command-line tools" >&2
    echo "For manual installation: https://developer.android.com/studio#command-line-tools-only" >&2
    exit 1
  fi

  # Verify download is not empty
  if [[ ! -s "${temp_dir}/commandlinetools.zip" ]]; then
    echo "$(basename "$0"): Downloaded file is empty" >&2
    echo "For manual installation: https://developer.android.com/studio#command-line-tools-only" >&2
    exit 1
  fi

  echo "Unzipping to ${temp_dir}..."
  if ! unzip -q "${temp_dir}/commandlinetools.zip" -d "${temp_dir}"; then
    echo "$(basename "$0"): Failed to unzip command-line tools" >&2
    echo "For manual installation: https://developer.android.com/studio#command-line-tools-only" >&2
    exit 1
  fi

  # Per https://developer.android.com/tools/sdkmanager
  local install_dir="$ANDROID_HOME/cmdline-tools/latest"
  echo "Creating installation directory ${install_dir}..."
  rm -rf "$ANDROID_HOME/cmdline-tools"
  if ! mkdir -p "${install_dir}"; then
    echo "$(basename "$0"): Failed to create directory ${install_dir}" >&2
    exit 1
  fi

  echo "Moving cmdline-tools contents to ${install_dir}..."
  if ! mv "${temp_dir}/cmdline-tools/"* "${install_dir}/"; then
    echo "$(basename "$0"): Failed to move cmdline-tools to ${install_dir}" >&2
    exit 1
  fi

  local sdkmanager_path="${install_dir}/bin/sdkmanager"
  # Conditionally patch sdkmanager to fix a quoting bug
  # shellcheck disable=SC2016
  if grep -q 'JAVA_VER=$($JAVACMD' "${sdkmanager_path}" 2>/dev/null; then
    echo "Patching sdkmanager to fix quoting bug..."
    cp "${sdkmanager_path}" "${sdkmanager_path}.backup"
    # shellcheck disable=SC2016
    if [[ "$os" == "mac" ]]; then
      sed -i '' 's/JAVA_VER=$($JAVACMD/JAVA_VER=$("$JAVACMD"/g' "${sdkmanager_path}"
    else
      sed -i 's/JAVA_VER=$($JAVACMD/JAVA_VER=$("$JAVACMD"/g' "${sdkmanager_path}"
    fi
  fi

  local avdmanager_path="${install_dir}/bin/avdmanager"
  # Conditionally patch avdmanager to fix a quoting bug
  # shellcheck disable=SC2016
  if grep -q 'JAVA_VER=$($JAVACMD' "${avdmanager_path}" 2>/dev/null; then
    echo "Patching avdmanager to fix quoting bug..."
    cp "${avdmanager_path}" "${avdmanager_path}.backup"
    # shellcheck disable=SC2016
    if [[ "$os" == "mac" ]]; then
      sed -i '' 's/JAVA_VER=$($JAVACMD/JAVA_VER=$("$JAVACMD"/g' "${avdmanager_path}"
    else
      sed -i 's/JAVA_VER=$($JAVACMD/JAVA_VER=$("$JAVACMD"/g' "${avdmanager_path}"
    fi
  fi

  # Clean up temp directory and remove trap
  rm -rf -- "$temp_dir"
  trap - EXIT
}

install_emulator() {
  if [[ -f "$ANDROID_HOME/emulator/emulator" ]]; then
    return 0
  fi

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
  if [[ ! -f "$sdkmanager" ]]; then
    echo "$(basename "$0"): sdkmanager not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  echo "Installing emulator..."
  yes | "${sdkmanager}" --licenses >/dev/null || true
  if ! timeout 300 "${sdkmanager}" --install "emulator"; then
    echo "$(basename "$0"): Failed to install emulator (timeout or error)" >&2
    echo "This may be due to network issues. Try running manually: ${sdkmanager} --install emulator" >&2
    exit 1
  fi
}

install_platform_tools() {
  if [[ -d "$ANDROID_HOME/platform-tools" ]]; then
    return 0
  fi

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
  if [[ ! -f "$sdkmanager" ]]; then
    echo "$(basename "$0"): sdkmanager not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  echo "Installing platform-tools..."
  yes | "${sdkmanager}" --licenses >/dev/null || true
  if ! timeout 300 "${sdkmanager}" --install "platform-tools"; then
    echo "$(basename "$0"): Failed to install platform-tools (timeout or error)" >&2
    echo "This may be due to network issues. Try running manually: ${sdkmanager} --install platform-tools" >&2
    exit 1
  fi
}

install_build_tools() {
  if [[ -d "$ANDROID_HOME/build-tools/${ANDROID_BUILD_TOOLS_VERSION}" ]]; then
    return 0
  fi

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
  if [[ ! -f "$sdkmanager" ]]; then
    echo "$(basename "$0"): sdkmanager not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  echo "Installing build-tools..."
  yes | "${sdkmanager}" --licenses >/dev/null || true
  if ! timeout 300 "${sdkmanager}" --install "build-tools;${ANDROID_BUILD_TOOLS_VERSION}"; then
    echo "$(basename "$0"): Failed to install build-tools (timeout or error)" >&2
    echo "This may be due to network issues. Try running manually: ${sdkmanager} --install build-tools;${ANDROID_BUILD_TOOLS_VERSION}" >&2
    exit 1
  fi
}

install_platforms() {

  if [[ -d "$ANDROID_HOME/platforms/${ANDROID_PLATFORM_VERSION}" ]]; then
    return 0
  fi

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

  if [[ ! -f "$sdkmanager" ]]; then
    echo "$(basename "$0"): sdkmanager not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  echo "Installing platforms;${ANDROID_PLATFORM_VERSION}... "

  yes | "${sdkmanager}" --licenses >/dev/null || true

  if ! timeout 300 "${sdkmanager}" --install "platforms;${ANDROID_PLATFORM_VERSION}"; then
    echo "$(basename "$0"): Failed to install platforms (timeout or error)" >&2
    echo "This may be due to network issues. Try running manually: ${sdkmanager} --install platforms;${ANDROID_PLATFORM_VERSION}" >&2
    exit 1
  fi

}

download_image() {
  local image_package="$1"
  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

  # Check if the image is installed, and install it if it's not
  local installed_packages
  installed_packages=$(env SKIP_JDK_VERSION_CHECK=1 "${sdkmanager}" --list_installed)
  if ! echo "${installed_packages}" | grep -q "${image_package}"; then
    echo "System image '${image_package}' not found. Installing..."
    yes | env SKIP_JDK_VERSION_CHECK=1 "${sdkmanager}" --licenses >/dev/null || true
    if ! env SKIP_JDK_VERSION_CHECK=1 "${sdkmanager}" --install "${image_package}"; then
      echo "Failed to install system image '${image_package}'. Please check if the package name is valid." >&2
      exit 1
    fi
  fi
}

find_available_emulator_port() {
  # Find an available port for starting an emulator.
  # This is necessary to ensure we can wait for the specific device we're starting,
  # rather than relying on ANDROID_SERIAL which may point to a different device.
  # Emulator ports must be even numbers between 5554 and 5584.
  local adb_path="$ANDROID_HOME/platform-tools/adb"

  # Get list of currently used emulator ports from adb devices
  local used_ports
  used_ports=$("${adb_path}" devices 2>/dev/null | grep "emulator-" | awk '{print $1}' | sed 's/emulator-//' || true)

  # Try ports from 5554 to 5584 (even numbers only)
  for port in $(seq 5554 2 5584); do
    local port_in_use=false

    # Check if this port is in the list of used ports
    for used_port in $used_ports; do
      if [[ "$port" == "$used_port" ]]; then
        port_in_use=true
        break
      fi
    done

    if [[ "$port_in_use" == false ]]; then
      echo "$port"
      return 0
    fi
  done

  # If we get here, all ports are in use
  echo "$(basename "$0"): No available emulator ports (5554-5584)" >&2
  exit 1
}

create_avd() {
  bootstrap
  require avdmanager

  local avd_name="$1"
  local device_type="$2"
  local image_package="$3"

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
  local avdmanager="$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager"

  if "${avdmanager}" list avd | grep -q "Name: ${avd_name}"; then
    echo "AVD '${avd_name}' already exists."
    return 0
  fi

  # Determine image package based on device type or use specified image
  if [[ -n "$image_package" ]]; then
    echo "Using specified image: ${image_package}"
  elif [[ -n "$device_type" ]]; then
    echo "Finding latest ${device_type} image..."
    image_package=$(get_latest_image_for_type "$device_type")
    echo "Selected image: ${image_package}"
  else
    image_package=$(get_default_image_package)
    echo "No device type or image specified, using default: ${image_package}"
  fi

  # Check if the image is installed, and install it if it's not
  local installed_packages
  installed_packages=$("${sdkmanager}" --list_installed)
  if ! echo "${installed_packages}" | grep -q "${image_package}"; then
    echo "System image '${image_package}' not found. Installing..."
    yes | "${sdkmanager}" --licenses >/dev/null || true
    if ! "${sdkmanager}" --install "${image_package}"; then
      echo "Failed to install system image '${image_package}'. Please check if the package name is valid." >&2
      exit 1
    fi
  fi

  echo "Creating AVD '${avd_name}' with image '${image_package}'..."

  # Determine device definition based on image type
  # Extract the tag (3rd field) from the image package
  # Format: system-images;API_LEVEL;TAG;ARCHITECTURE
  # To see all available device definitions, run: avdmanager list device
  local image_tag
  image_tag=$(echo "${image_package}" | awk -F';' '{print $3}')

  # Choose device definition based on image type
  local device_arg=""
  if [[ "$image_tag" == *"wear"* ]]; then
    # Wear OS image - use wearos device definition
    device_arg="-d wearos_large_round"
    echo "Detected Wear OS image, using device definition: wearos_large_round"
  else
    # Mobile/tablet image - use medium_phone device definition
    device_arg="-d medium_phone"
    echo "Detected mobile/tablet image, using device definition: medium_phone"
  fi

  # Create AVD with appropriate device definition
  # shellcheck disable=SC2086
  echo "no" | "${avdmanager}" create avd -n "${avd_name}" -k "${image_package}" ${device_arg}
}

start_avd() {
  bootstrap
  require emulator adb

  # Parse flags and AVD name (flags can appear in any position)
  local cold_boot=false
  local wipe_data=false
  local avd_name=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --cold-boot)
        cold_boot=true
        shift
        ;;
      --wipe-data)
        wipe_data=true
        shift
        ;;
      -*)
        echo "$(basename "$0") start: unknown flag '$1'" >&2
        echo "Valid flags: --cold-boot, --wipe-data" >&2
        exit 1
        ;;
      *)
        # This is the AVD name
        if [[ -n "$avd_name" ]]; then
          echo "$(basename "$0") start: multiple AVD names specified: '$avd_name' and '$1'" >&2
          exit 1
        fi
        avd_name="$1"
        shift
        ;;
    esac
  done

  # Validate that AVD name was provided
  if [[ -z "$avd_name" ]]; then
    echo "$(basename "$0") start: AVD name required" >&2
    exit 1
  fi

  # --wipe-data implies cold boot
  if [[ "$wipe_data" == true ]]; then
    cold_boot=true
  fi

  # Check if AVD exists by listing them
  local all_avds
  all_avds=$("$ANDROID_HOME/emulator/emulator" -list-avds)
  if ! echo "$all_avds" | grep -q "^${avd_name}$"; then
    echo "$(basename "$0"): AVD '${avd_name}' does not exist. Available AVDs:" >&2
    echo "$all_avds" >&2
    exit 1
  fi

  local image_package
  image_package=$(get_avd_image_package "$avd_name")

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
  local installed_packages
  installed_packages=$("$sdkmanager" --list_installed)
  if ! echo "${installed_packages}" | grep -q "${image_package}"; then
    echo "System image '${image_package}' for AVD '${avd_name}' not found." >&2
    echo "Please download it using the following command:" >&2
    echo "  $(basename "$0") download \"${image_package}\"" >&2
    exit 1
  fi

  # Check if AVD is already running
  local running_avds
  running_avds=$(list_avds | grep '(emulator-' | awk '{print $1}' || true)
  if echo "$running_avds" | grep -q "^${avd_name}$"; then
    echo "AVD '${avd_name}' is already running."
    return 0
  fi

  local emulator_path="$ANDROID_HOME/emulator/emulator"
  if [[ ! -f "${emulator_path}" ]]; then
    echo "$(basename "$0"): emulator not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  # Check for platform-tools
  if [[ ! -d "$ANDROID_HOME/platform-tools" ]]; then
    echo "$(basename "$0"): platform-tools not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  local adb_path="$ANDROID_HOME/platform-tools/adb"
  if [[ ! -f "${adb_path}" ]]; then
    echo "$(basename "$0"): adb not found. Please run 'bootstrap' first." >&2
    exit 1
  fi

  # Check for hardware acceleration and provide a streamlined error message
  local acceleration_ok=true
  if [[ "$(uname -s)" == "Linux" && "$(get_host_arch)" == "x86_64" ]]; then
    if [[ ! -e /dev/kvm ]] || ! grep -q -E 'vmx|svm' /proc/cpuinfo; then
      acceleration_ok=false
    fi
  elif [[ "$(uname -s)" == "Darwin" ]]; then
    if ! sysctl -a | grep -q "kern.hv_support: 1"; then
      acceleration_ok=false
    fi
  fi

  if [[ "$acceleration_ok" == false ]]; then
    echo "$(basename "$0"): ERROR: Hardware acceleration is not available." >&2
    echo "This is required to run the emulator." >&2
    echo "For a detailed diagnosis, run: $(basename "$0") doctor" >&2
    exit 1
  fi

  # Find an available port to avoid conflicts with ANDROID_SERIAL
  local emulator_port
  emulator_port=$(find_available_emulator_port)
  local emulator_serial="emulator-${emulator_port}"

  # Build emulator command with appropriate flags
  local emulator_flags="-avd ${avd_name} -port ${emulator_port}"
  local boot_mode="Quick Boot"

  if [[ "$cold_boot" == true ]]; then
    emulator_flags="${emulator_flags} -no-snapshot-load"
    boot_mode="Cold Boot"
  fi

  if [[ "$wipe_data" == true ]]; then
    emulator_flags="${emulator_flags} -wipe-data"
    boot_mode="Factory Reset + Cold Boot"
  fi

  echo "Starting AVD '${avd_name}' on port ${emulator_port} (serial: ${emulator_serial}) [${boot_mode}]..."
  local emulator_log
  emulator_log=$(mktemp)
  # shellcheck disable=SC2086
  nohup "${emulator_path}" ${emulator_flags} >"${emulator_log}" 2>&1 &

  echo ""
  echo "To debug emulator issues, run this command:"
  # shellcheck disable=SC2086
  echo "  ${emulator_path} ${emulator_flags} -verbose -show-kernel -no-audio"
  echo ""

  echo "Waiting for device ${emulator_serial} to connect (timeout: 120s)..."
  if ! timeout 120 "${adb_path}" -s "${emulator_serial}" wait-for-device; then
    echo "$(basename "$0"): Timeout waiting for device to connect" >&2
    echo "The emulator may still be starting. Check with: ${adb_path} devices" >&2
    echo "Or debug with the command shown above" >&2
    echo "--- Emulator Output --- $(date) --- " >&2
    cat "${emulator_log}" >&2
    echo "--- End Emulator Output --- $(date) --- " >&2
    rm -f "${emulator_log}"
    exit 1
  fi

  echo "Waiting for boot animation to stop..."
  while [ "$("${adb_path}" -s "${emulator_serial}" shell getprop init.svc.bootanim 2>/dev/null | tr -d '\r')" != "stopped" ]; do
    sleep 1
  done

  rm -f "${emulator_log}"
  echo "Device ${emulator_serial} connected and boot animation finished."
}

stop_avd() {
  bootstrap
  require adb emulator

  local avd_name_to_stop="$1"

  # Check if AVD exists
  if ! "$ANDROID_HOME/emulator/emulator" -list-avds | grep -q "^${avd_name_to_stop}$"; then
    echo "$(basename "$0"): AVD '${avd_name_to_stop}' does not exist." >&2
    exit 1
  fi

  local adb_path="$ANDROID_HOME/platform-tools/adb"

  echo "Attempting to stop AVD '$avd_name_to_stop'..."

  # Get serial numbers of all online emulator devices
  local device_serials
  device_serials=$("${adb_path}" devices | grep "emulator-" | awk '{print $1}' || true)

  if [[ -z "$device_serials" ]]; then
    echo "No running emulators found."
    return 0
  fi

  local found_avd=false
  for serial in $device_serials; do
    # Get the AVD name for the current device and trim whitespace/carriage returns
    local running_avd_name
    running_avd_name=$("${adb_path}" -s "$serial" shell getprop ro.boot.qemu.avd_name | tr -d '[:space:]')

    if [[ "$running_avd_name" == "$avd_name_to_stop" ]]; then
      echo "Found running AVD '$avd_name_to_stop' on device '$serial'. Stopping it..."
      "${adb_path}" -s "$serial" emu kill
      echo "AVD '$avd_name_to_stop' stopped."
      found_avd=true
      break # Stop after finding and killing the first match
    fi
  done

  if [[ "$found_avd" == false ]]; then
    echo "AVD '$avd_name_to_stop' is not currently running."
  fi
}

delete_avd() {
  bootstrap
  require avdmanager emulator

  local avd_name="$1"
  local avd_dir="$ANDROID_USER_HOME/avd/${avd_name}.avd"
  local avd_ini="$ANDROID_USER_HOME/avd/${avd_name}.ini"

  # Check if AVD exists
  if ! "$ANDROID_HOME/emulator/emulator" -list-avds | grep -q "^${avd_name}$"; then
    # AVD not registered, but check for orphaned files
    if [[ -d "$avd_dir" ]] || [[ -f "$avd_ini" ]]; then
      echo "AVD '${avd_name}' is not registered, but orphaned files exist. Cleaning up..."
      [[ -d "$avd_dir" ]] && rm -rf "$avd_dir" && echo "  Removed directory: $avd_dir"
      [[ -f "$avd_ini" ]] && rm -f "$avd_ini" && echo "  Removed file: $avd_ini"
      echo "Orphaned files cleaned up successfully."
      return 0
    fi
    echo "$(basename "$0"): AVD '${avd_name}' does not exist." >&2
    exit 1
  fi

  # Check if AVD is running and stop it
  local running_avds
  running_avds=$(list_avds | grep '(emulator-' | awk '{print $1}' || true)
  if echo "$running_avds" | grep -q "^${avd_name}$"; then
    echo "AVD '${avd_name}' is running. Stopping it first..."
    stop_avd "${avd_name}"
  fi

  local avdmanager_path="$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager"
  echo "Deleting AVD '${avd_name}'..."

  "${avdmanager_path}" delete avd -n "${avd_name}"

  # Verify that the AVD has been deleted (with retry)
  local attempts=0
  while [[ $attempts -lt 3 ]]; do
    if ! "${avdmanager_path}" list avd | grep -q "Name: ${avd_name}"; then
      # Give avdmanager a moment to finish cleaning up files.
      # There appears to be a bug where avdmanager successfully removes the AVD
      # from its registry but leaves the .avd directory behind, especially when
      # the AVD was recently running. This delay gives it a chance to complete.
      sleep 2

      # Clean up any remaining files that avdmanager didn't remove
      local cleaned=false
      if [[ -d "$avd_dir" ]]; then
        rm -rf "$avd_dir"
        cleaned=true
      fi
      if [[ -f "$avd_ini" ]]; then
        rm -f "$avd_ini"
        cleaned=true
      fi

      if [[ "$cleaned" == true ]]; then
        echo "AVD '${avd_name}' deleted and cleaned up successfully."
      else
        echo "AVD '${avd_name}' deleted successfully."
      fi
      return 0
    fi
    attempts=$((attempts + 1))
    sleep 1
  done

  echo "$(basename "$0"): Failed to delete AVD '${avd_name}'." >&2
  exit 1
}

list_avds() {
  bootstrap
  require emulator adb

  local emulator_path="$ANDROID_HOME/emulator/emulator"
  local adb_path="$ANDROID_HOME/platform-tools/adb"

  # Get all available AVDs
  local all_avds
  all_avds=$("${emulator_path}" -list-avds)

  # If --names-only flag is provided, output just the names and return
  if [[ "${1:-}" == "--names-only" ]]; then
    echo "$all_avds"
    return 0
  fi

  # Build a map of AVD name -> serial number for running AVDs
  declare -A avd_serials
  local device_serials
  device_serials=$(timeout 5 "${adb_path}" devices | grep "emulator-" | awk '{print $1}' || true)

  if [[ -n "$device_serials" ]]; then
    for serial in $device_serials; do
      local avd_name
      avd_name=$(timeout 5 "${adb_path}" -s "$serial" shell getprop ro.boot.qemu.avd_name | tr -d '[:space:]' || true)
      if [[ -n "$avd_name" ]]; then
        avd_serials["$avd_name"]="$serial"
      fi
    done
  fi

  # If --running-only flag is provided, output only running AVD names
  if [[ "${1:-}" == "--running-only" ]]; then
    for avd_name in "${!avd_serials[@]}"; do
      echo "$avd_name"
    done | sort
    return 0
  fi

  # If --stopped-only flag is provided, output only stopped AVD names
  if [[ "${1:-}" == "--stopped-only" ]]; then
    if [[ -z "$all_avds" ]]; then
      return 0
    fi
    echo "$all_avds" | while IFS= read -r avd; do
      if [[ -z "$avd" ]]; then
        continue
      fi
      # Output only if this AVD is NOT running
      if [[ -z "${avd_serials[$avd]:-}" ]]; then
        echo "$avd"
      fi
    done
    return 0
  fi

  # Print the list with serial numbers for running AVDs
  if [[ -z "$all_avds" ]]; then
    return 0
  fi

  echo "$all_avds" | while IFS= read -r avd; do
    if [[ -z "$avd" ]]; then
      continue
    fi

    # Check if this AVD is running and has a serial number
    if [[ -n "${avd_serials[$avd]:-}" ]]; then
      echo "$avd (${avd_serials[$avd]})"
    else
      echo "$avd"
    fi
  done
}

list_images() {
  bootstrap
  require sdkmanager

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

  # Determine host architecture for filtering
  local arch_filter
  arch_filter=$(get_host_arch)

  # Get all available system images and installed packages
  local all_packages_raw
  if ! all_packages_raw=$(timeout 120 "$sdkmanager" --list 2>&1); then
    echo "$(basename "$0"): Failed to list available packages (timeout or error)" >&2
    echo "This may be due to network issues. Try running manually: ${sdkmanager} --list" >&2
    exit 1
  fi
  local installed_packages
  if ! installed_packages=$(timeout 120 "$sdkmanager" --list_installed 2>&1 | awk -F'|' '{print $1}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'); then
    echo "$(basename "$0"): Failed to list installed packages (timeout or error)" >&2
    exit 1
  fi

  (echo "$all_packages_raw" | { grep "system-images;android-" | grep "$arch_filter" || true; } | while IFS= read -r line; do
    # Extract package path and trim whitespace
    local package_path
    package_path=$(echo "$line" | awk -F'|' '{print $1}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # Extract API level/version (second field in package path)
    local api_part
    api_part=$(echo "$package_path" | awk -F';' '{print $2}')
    local version_string
    version_string="${api_part#android-}"

    # Only accept numeric versions (with optional decimal point)
    # Skip CANARY, letter codenames (Baklava), and versions with suffixes (36.0-Baklava)
    if ! is_numeric_version "$version_string"; then
      continue
    fi

    # Extract major version for filtering
    local major_version
    major_version=$(echo "$version_string" | cut -d'.' -f1)

    # Check if major version is greater than or equal to 33
    if [[ "$major_version" -ge 33 ]]; then
      # Check if the package is installed
      if echo "$installed_packages" | grep -q -x "$package_path"; then
        echo "* $package_path"
      else
        echo "  $package_path"
      fi
    fi
  done) | sort | uniq
}

get_ini_value() {
  local file="$1"
  local key="$2"
  awk -F= -v key="$key" '
    $0 ~ "^" key "[[:space:]]*=" {
      # Remove the key and equals sign
      sub("^[^=]*=[[:space:]]*", "")
      # Remove trailing whitespace and carriage returns
      gsub(/[[:space:]]*$/, "")
      gsub(/\r/, "")
      print
      exit
    }
  ' "$file"
}

info_avd() {

  local avd_name="$1"
  local avd_ini="$ANDROID_USER_HOME/avd/${avd_name}.ini"
  local adb_path="$ANDROID_HOME/platform-tools/adb"

  if [[ ! -f "$avd_ini" ]]; then
    echo "$(basename "$0"): AVD '${avd_name}' does not exist." >&2
    exit 1
  fi

  # Get AVD directory path
  local avd_path
  avd_path=$(get_ini_value "$avd_ini" "path")
  local config_ini="${avd_path}/config.ini"

  if [[ ! -f "$config_ini" ]]; then
    echo "$(basename "$0"): AVD configuration file not found at ${config_ini}" >&2
    exit 1
  fi

  # Extract information from config.ini
  local display_name api_level sysdir tag_display abi_type device_name
  local lcd_width lcd_height lcd_density lcd_circular ram_size data_size
  local sdcard_size playstore_enabled

  display_name=$(get_ini_value "$config_ini" "avd.ini.displayname")
  sysdir=$(get_ini_value "$config_ini" "image.sysdir.1")
  # Extract API level from sysdir (e.g., "system-images/android-36/..." -> "36")
  local temp="${sysdir#*android-}"
  api_level="${temp%%/*}"
  tag_display=$(get_ini_value "$config_ini" "tag.display")
  abi_type=$(get_ini_value "$config_ini" "abi.type")
  device_name=$(get_ini_value "$config_ini" "hw.device.name")
  lcd_width=$(get_ini_value "$config_ini" "hw.lcd.width")
  lcd_height=$(get_ini_value "$config_ini" "hw.lcd.height")
  lcd_density=$(get_ini_value "$config_ini" "hw.lcd.density")
  lcd_circular=$(get_ini_value "$config_ini" "hw.lcd.circular")
  ram_size=$(get_ini_value "$config_ini" "hw.ramSize")
  data_size=$(get_ini_value "$config_ini" "disk.dataPartition.size")
  sdcard_size=$(get_ini_value "$config_ini" "sdcard.size")
  playstore_enabled=$(get_ini_value "$config_ini" "PlayStore.enabled")

  local package_name
  package_name=$(get_avd_image_package "$avd_name")

  # Check if AVD is running
  local is_running=false
  local serial_number=""
  local device_serials
  device_serials=$(timeout 5 "${adb_path}" devices | grep "emulator-" | awk '{print $1}' || true)

  if [[ -n "$device_serials" ]]; then
    for serial in $device_serials; do
      local running_avd_name
      running_avd_name=$(timeout 5 "${adb_path}" -s "$serial" shell getprop ro.boot.qemu.avd_name 2>/dev/null | tr -d '[:space:]' || true)
      if [[ "$running_avd_name" == "$avd_name" ]]; then
        is_running=true
        serial_number="$serial"
        break
      fi
    done
  fi

  # Display information
  echo "AVD Information: ${avd_name}"
  if [[ -n "$display_name" ]]; then
    echo "  Display Name: ${display_name}"
  fi

  if [[ "$is_running" == true ]]; then
    echo "  Status: Running (${serial_number})"
  else
    echo "  Status: Stopped"
  fi

  echo ""
  echo "System Image:"
  if [[ -n "$package_name" ]]; then
    echo "  Package: ${package_name}"
  fi
  if [[ -n "$api_level" ]]; then
    echo "  API Level: ${api_level}"
  fi
  if [[ -n "$tag_display" ]]; then
    echo "  Tag: ${tag_display}"
  fi
  if [[ -n "$abi_type" ]]; then
    echo "  Architecture: ${abi_type}"
  fi

  echo ""
  echo "Device Configuration:"
  if [[ -n "$device_name" ]]; then
    echo "  Profile: ${device_name}"
  fi
  if [[ -n "$lcd_width" && -n "$lcd_height" ]]; then
    local screen_info="${lcd_width}x${lcd_height}"
    if [[ -n "$lcd_density" ]]; then
      screen_info="${screen_info} (${lcd_density} dpi"
      if [[ "$lcd_circular" == "true" ]]; then
        screen_info="${screen_info}, circular)"
      else
        screen_info="${screen_info})"
      fi
    fi
    echo "  Screen: ${screen_info}"
  fi
  if [[ -n "$ram_size" ]]; then
    echo "  RAM: ${ram_size} MB"
  fi
  if [[ -n "$data_size" ]]; then
    echo "  Storage: ${data_size}"
  fi
  if [[ -n "$sdcard_size" ]]; then
    echo "  SD Card: ${sdcard_size}"
  fi
  if [[ -n "$playstore_enabled" ]]; then
    if [[ "$playstore_enabled" == "true" ]]; then
      echo "  Play Store: Yes"
    else
      echo "  Play Store: No"
    fi
  fi

  echo ""
  echo "Path: ${avd_path}"
}

get_avd_image_package() {
  local avd_name="$1"
  local avd_ini="$ANDROID_USER_HOME/avd/${avd_name}.ini"
  local sysdir

  if [[ ! -f "$avd_ini" ]]; then
    echo "$(basename "$0"): AVD '${avd_name}' does not exist." >&2
    exit 1
  fi

  local avd_path
  avd_path=$(get_ini_value "$avd_ini" "path")
  local config_ini="${avd_path}/config.ini"

  if [[ ! -f "$config_ini" ]]; then
    echo "$(basename "$0"): AVD configuration file not found at ${config_ini}" >&2
    exit 1
  fi

  sysdir=$(get_ini_value "$config_ini" "image.sysdir.1")

  if [[ -n "$sysdir" ]]; then
    echo "$sysdir" | sed 's|system-images/|system-images;|' | sed 's|/|;|g' | sed 's|;$||'
  fi
}

check_outdated() {
  bootstrap
  require sdkmanager

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

  echo "Checking for outdated packages..."
  echo ""
  "${sdkmanager}" --list | grep -A 1000 "Updates" || echo "All packages are up to date."
}

update_packages() {
  bootstrap
  require sdkmanager

  local sdkmanager="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

  echo "Updating all installed packages..."
  yes | "${sdkmanager}" --licenses >/dev/null || true

  if ! "${sdkmanager}" --update; then
    echo "$(basename "$0"): Failed to update packages" >&2
    echo "Try running manually: ${sdkmanager} --update" >&2
    exit 1
  fi

  echo "All packages updated successfully."
}

run_doctor() {
  echo "Running diagnostics..."
  echo ""

  local warnings=0
  local errors=0

  # Check for orphaned crashpad_handler processes
  local crashpad_count
  crashpad_count=$(pgrep -f 'android-sdk/emulator/crashpad_handler' | grep -c . || true)
  if [[ "$crashpad_count" -gt 0 ]]; then
    echo "[WARN] Found $crashpad_count orphaned crashpad_handler processes"
    echo "       These are leftover crash reporters from previous emulator sessions."
    echo "       To clean up: pkill -f 'android-sdk/emulator/crashpad_handler'"
    echo ""
    warnings=$((warnings + 1))
  else
    echo "[OK]   No orphaned crashpad_handler processes"
  fi

  # Check for orphaned emulator processes
  local emulator_count
  emulator_count=$(pgrep -f 'emulator/emulator.*-avd' | grep -c . || true)
  if [[ "$emulator_count" -gt 0 ]]; then
    echo "[INFO] Found $emulator_count running emulator process(es)"
    # Get list of running AVDs
    if [[ -f "$ANDROID_HOME/platform-tools/adb" ]]; then
      local running_avds
      running_avds=$("$ANDROID_HOME/platform-tools/adb" devices 2>/dev/null | grep -c "emulator-" || echo "0")
      echo "       Connected devices: $running_avds"
    fi
    echo ""
  else
    echo "[OK]   No emulator processes running"
  fi

  # Check disk space for ANDROID_HOME
  if [[ -d "$ANDROID_HOME" ]]; then
    local avail_space
    if [[ "$(uname -s)" == "Darwin" ]]; then
      avail_space=$(df -h "$ANDROID_HOME" | tail -1 | awk '{print $4}')
    else
      avail_space=$(df -h "$ANDROID_HOME" | tail -1 | awk '{print $4}')
    fi
    local avail_gb
    avail_gb=$(df -g "$ANDROID_HOME" 2>/dev/null | tail -1 | awk '{print $4}' || echo "0")

    if [[ "$avail_gb" -lt 5 ]]; then
      echo "[WARN] Low disk space: ${avail_space} available at ANDROID_HOME"
      echo "       AVD images can be several GB each. Consider freeing up space."
      echo ""
      warnings=$((warnings + 1))
    else
      echo "[OK]   Disk space: ${avail_space} available at ANDROID_HOME"
    fi
  fi

  # Check for orphaned/mismatched AVD files
  if [[ -d "$ANDROID_USER_HOME/avd" ]]; then
    local avd_base_path="$ANDROID_USER_HOME/avd"
    local has_orphans=false

    # Arrays to store all .ini files and .avd directories
    declare -a all_ini_files
    while IFS= read -r file; do
      all_ini_files+=("$file")
    done < <(find "$avd_base_path" -maxdepth 1 -name "*.ini" -type f)

    declare -a all_avd_dirs
    while IFS= read -r dir; do
      all_avd_dirs+=("$dir")
    done < <(find "$avd_base_path" -maxdepth 1 -name "*.avd" -type d)

    # Track which AVD directories are referenced by .ini files using associative array
    declare -A referenced_avd_dirs

    declare -a orphaned_inis=()
    declare -a orphaned_ini_reasons=()
    # Check for orphaned .ini files
    for ini_file in "${all_ini_files[@]}"; do
      local avd_path
      avd_path=$(get_ini_value "$ini_file" "path")

      if [[ -z "$avd_path" ]]; then
        orphaned_inis+=("$ini_file")
        orphaned_ini_reasons+=("malformed: missing 'path' entry")
        has_orphans=true
        continue
      fi

      if [[ ! -d "$avd_path" ]]; then
        orphaned_inis+=("$ini_file")
        orphaned_ini_reasons+=("points to missing directory: $avd_path")
        has_orphans=true
      else
        referenced_avd_dirs["$avd_path"]=1
      fi
    done

    declare -a orphaned_avds=()
    # Check for orphaned .avd directories
    for avd_dir in "${all_avd_dirs[@]}"; do
      if [[ -z "${referenced_avd_dirs[$avd_dir]:-}" ]]; then
        orphaned_avds+=("$avd_dir")
        has_orphans=true
      fi
    done

    if [[ ${#orphaned_inis[@]} -gt 0 ]]; then
      echo "[WARN] Found orphaned AVD .ini files:"
      local i=0
      for orphan in "${orphaned_inis[@]}"; do
        echo "       - $orphan (${orphaned_ini_reasons[$i]})"
        i=$((i + 1))
      done
    fi

    if [[ ${#orphaned_avds[@]} -gt 0 ]]; then
      echo "[WARN] Found orphaned AVD directories (not referenced by any .ini file):"
      for orphan in "${orphaned_avds[@]}"; do
        echo "       - $orphan"
      done
    fi

    if [[ "$has_orphans" == "true" ]]; then
      warnings=$((warnings + 1))
      declare -A unique_names_to_delete
      for orphan in "${orphaned_inis[@]}"; do
        local name
        name=$(basename "$orphan" .ini)
        unique_names_to_delete["$name"]=1
      done
      for orphan in "${orphaned_avds[@]}"; do
        local name
        name=$(basename "$orphan" .avd)
        unique_names_to_delete["$name"]=1
      done

      if [[ ${#unique_names_to_delete[@]} -gt 0 ]]; then
        echo "       To clean up, run:"
        for name in "${!unique_names_to_delete[@]}"; do
          echo "         $(basename "$0") delete \"$name\""
        done | sort
      fi
      echo ""
    else
      echo "[OK]   No orphaned AVD files found"
    fi
  fi

  # Check for Java environment
  local javacmd=""
  local resolution_method=""
  if [[ -n "${JAVA_HOME:-}" ]] && [[ -x "$JAVA_HOME/bin/java" ]]; then
    javacmd="$JAVA_HOME/bin/java"
    resolution_method="\$JAVA_HOME"
  elif command -v java &>/dev/null; then
    javacmd=$(command -v java)
    resolution_method="PATH"
  fi

  if [[ -z "$javacmd" ]]; then
    echo "[ERROR] Java executable not found"
    echo "        Android SDK requires Java 17 or higher."
    echo "        Please set JAVA_HOME or add 'java' to your PATH."
    echo ""
    errors=$((errors + 1))
  else
    local java_version_string
    java_version_string=$("$javacmd" -version 2>&1 | head -n 1)
    local java_major_version
    # Regex to extract major version for formats like "1.8.0_292" (version 8) and "11.0.12" (version 11) or "17.0.1" (version 17)
    java_major_version=$(echo "$java_version_string" | sed -E -n 's/.*version "((1\.)?([0-9]+))\..*".*/\3/p')

    if [[ -z "$java_major_version" ]]; then
      echo "[WARN] Could not determine Java version."
      echo "       Java executable: $javacmd (found via $resolution_method)"
      echo "       'java -version' output:"
      echo "       $java_version_string"
      echo ""
      warnings=$((warnings + 1))
    elif [[ "$java_major_version" -lt 17 ]]; then
      echo "[ERROR] Java version is too old: $java_major_version"
      echo "        Java executable: $javacmd (found via $resolution_method)"
      echo "        Android SDK requires Java 17 or higher."
      echo ""
      errors=$((errors + 1))
    else
      echo "[OK]   Java version: $java_major_version"
      echo "       - Path: $javacmd"
      echo "       - Source: $resolution_method"
    fi
  fi

  # Check for hardware acceleration
  if [[ "$(uname -s)" == "Linux" ]]; then
    if [[ ! -e /dev/kvm ]]; then
      echo "[ERROR] KVM not found at /dev/kvm"
      echo "        Hardware acceleration is required for running x86_64 emulators on Linux."
      echo "        Please ensure KVM is enabled in your BIOS and the module is loaded."
      echo ""
      errors=$((errors + 1))
    elif ! grep -q -E 'vmx|svm' /proc/cpuinfo; then
      echo "[ERROR] CPU does not support virtualization extensions (VT-x or AMD-V)"
      echo "        KVM acceleration is required for x86_64 emulators on Linux."
      echo "        Please ensure virtualization is enabled in your BIOS."
      echo ""
      errors=$((errors + 1))
    elif ! groups | grep -q "\\bkvm\\b"; then
      echo "[WARN] User is not in the 'kvm' group."
      echo "       Emulator may fail to start or run slowly."
      echo "       To fix, run: sudo usermod -aG kvm \$USER"
      echo "       You may need to log out and log back in for the changes to take effect."
      echo ""
      warnings=$((warnings + 1))
    else
      echo "[OK]   KVM is enabled and user is in the 'kvm' group"
    fi
  elif [[ "$(uname -s)" == "Darwin" ]]; then
    if [[ "$(sysctl -n kern.hv.supported)" -eq 1 ]]; then
      echo "[OK]   Hypervisor Framework (HVF) is enabled"
    else
      echo "[ERROR] Hypervisor Framework (HVF) is not enabled"
      echo "        Hardware acceleration is required for running emulators on macOS."
      echo "        This is typically available on macOS 10.10 (Yosemite) and newer."
      echo "        To check your system, run: sysctl kern.hv.supported"
      echo ""
      errors=$((errors + 1))
    fi
  fi

  # Check for SDK tools
  if [[ ! -d "$ANDROID_HOME/cmdline-tools/latest" ]]; then
    echo "[ERROR] Android SDK command-line tools not found"
    echo "        Run: $(basename "$0") bootstrap"
    echo ""
    errors=$((errors + 1))
  else
    echo "[OK]   Android SDK command-line tools installed"
  fi

  if [[ ! -d "$ANDROID_HOME/platform-tools" ]]; then
    echo "[ERROR] Android platform-tools not found"
    echo "        Run: $(basename "$0") bootstrap"
    echo ""
    errors=$((errors + 1))
  else
    echo "[OK]   Android platform-tools installed"
  fi

  if [[ ! -d "$ANDROID_HOME/emulator" ]]; then
    echo "[ERROR] Android emulator not found"
    echo "        Run: $(basename "$0") bootstrap"
    echo ""
    errors=$((errors + 1))
  else
    echo "[OK]   Android emulator installed"
  fi

  # Summary
  echo ""
  if [[ "$errors" -eq 0 && "$warnings" -eq 0 ]]; then
    echo "No issues found"
  else
    echo "Diagnostics complete: $errors error(s), $warnings warning(s)"
    if [[ "$errors" -gt 0 ]]; then
      return 1
    fi
  fi
  return 0
}

bootstrap() {
  install_cli_tools
  install_platform_tools
  install_build_tools
  install_platforms
  install_emulator
}

case "$1" in
  bootstrap)
    bootstrap
    ;;
  doctor)
    run_doctor
    ;;
  list)
    list_avds "${2:-}"
    ;;
  info)
    if [[ -z "${2:-}" ]]; then
      echo "$(basename "$0") info: AVD name required" >&2
      exit 1
    fi
    info_avd "$2"
    ;;
  images)
    list_images
    ;;
  outdated)
    check_outdated
    ;;
  update)
    update_packages
    ;;
  create)
    # Parse create command arguments
    # Supports: create <name> [--mobile|--phone|--wear|--watch] [image]
    avd_name=""
    device_type=""
    image_package=""
    shift # skip "create"

    while [[ $# -gt 0 ]]; do
      case "$1" in
        --mobile | --phone)
          if [[ -n "$device_type" ]]; then
            echo "$(basename "$0") create: multiple device types specified" >&2
            exit 1
          fi
          device_type="mobile"
          shift
          ;;
        --wear | --watch)
          if [[ -n "$device_type" ]]; then
            echo "$(basename "$0") create: multiple device types specified" >&2
            exit 1
          fi
          device_type="wear"
          shift
          ;;
        --tv)
          if [[ -n "$device_type" ]]; then
            echo "$(basename "$0") create: multiple device types specified" >&2
            exit 1
          fi
          device_type="tv"
          shift
          ;;
        --auto)
          if [[ -n "$device_type" ]]; then
            echo "$(basename "$0") create: multiple device types specified" >&2
            exit 1
          fi
          device_type="auto"
          shift
          ;;
        --*)
          echo "$(basename "$0") create: unknown option '$1'" >&2
          echo "Valid options: --mobile, --phone, --wear, --watch, --tv, --auto" >&2
          exit 1
          ;;
        *)
          # Non-flag argument
          if [[ -z "$avd_name" ]]; then
            avd_name="$1"
          elif [[ -z "$image_package" ]]; then
            image_package="$1"
          else
            echo "$(basename "$0") create: too many arguments" >&2
            exit 1
          fi
          shift
          ;;
      esac
    done

    if [[ -z "$avd_name" ]]; then
      echo "$(basename "$0") create: AVD name required" >&2
      exit 1
    fi

    create_avd "$avd_name" "$device_type" "$image_package"
    ;;
  start)
    start_avd "${@:2}"
    ;;
  stop)
    if [[ -z "${2:-}" ]]; then
      echo "$(basename "$0") stop: AVD name required" >&2
      exit 1
    fi
    stop_avd "$2"
    ;;
  delete)
    if [[ -z "${2:-}" ]]; then
      echo "$(basename "$0") delete: AVD name required" >&2
      exit 1
    fi
    delete_avd "$2"
    ;;
  download)
    if [[ -z "${2:-}" ]]; then
      echo "$(basename "$0") download: image name required" >&2
      exit 1
    fi
    download_image "$2"
    ;;
  *)
    echo "$(basename "$0"): unknown command '$1'" >&2
    usage 1
    ;;
esac
