#!/usr/bin/env bash

# context - Generate aggregated context for various topics
#
# Each topic is a bash function that uses fetch() to download sources
# and run() to output content in a shell_session XML format.

set -e

SCRIPT_NAME=$(basename "$0")

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

require() {
  hash "$@" || {
    echo "$SCRIPT_NAME: command '$1' not found" >&2
    exit 127
  }
}

xml_escape() {
  python3 -c 'import sys, html; print(html.escape(sys.stdin.read()), end="")'
}

cdata_escape() {
  python3 -c '
import sys
d = sys.stdin.read()
d = d.translate({i: None for i in range(32) if i not in (9, 10, 13)})
print(d.replace("]]>", "]]]]><![CDATA[>"), end="")
'
}

is_binary() {
  grep -q $'\x00'
}

# run DISPLAY_CMD [SOURCE_CMD]
#
# Captures a command and its output as XML. The first argument is displayed
# in the <command> element. The second argument, if provided, is the command
# actually executed; if omitted, it defaults to DISPLAY_CMD.
run() {
  local display_cmd="$1"
  local source_cmd="${2:-$1}"
  local output status

  output=$(eval "$source_cmd" 2>/dev/null)
  status=$?

  if [[ $status -ne 0 ]]; then
    printf "<error>\n"
    printf "<command>%s</command>\n" "$(printf '%s' "$display_cmd" | xml_escape)"
    printf "<message>Command failed with exit status %d</message>\n" "$status"
    printf "</error>\n"
    return
  fi

  if printf '%s' "$output" | is_binary; then
    printf "<error>\n"
    printf "<command>%s</command>\n" "$(printf '%s' "$display_cmd" | xml_escape)"
    printf "<message>Binary content detected</message>\n"
    printf "</error>\n"
    return
  fi

  printf "<entry>\n"
  printf "<command>%s</command>\n" "$(printf '%s' "$display_cmd" | xml_escape)"
  printf "<output><![CDATA[%s]]></output>\n" "$(printf '%s' "$output" | cdata_escape)"
  printf "</entry>\n"
}

# fetch - Download a source and return its local path
#
# Usage:
#   fetch github://owner/repo              Download default branch
#   fetch github://owner/repo@branch       Download specific branch
#   fetch https://example.com/file.txt     Download URL
fetch() {
  local url="$1"

  if [[ "$url" =~ ^github://(.+) ]]; then
    local repo_spec="${BASH_REMATCH[1]}"
    local repo branch="main"

    if [[ "$repo_spec" =~ ^(.+)@(.+)$ ]]; then
      repo="${BASH_REMATCH[1]}"
      branch="${BASH_REMATCH[2]}"
    else
      repo="$repo_spec"
    fi

    local repo_slug="${repo//\//-}"
    local extract_dir="$BUILD_DIR/repos/$repo_slug"

    if [[ ! -d "$extract_dir" ]]; then
      local archive_url="https://github.com/${repo}/archive/refs/heads/${branch}.zip"
      local zip_file="$BUILD_DIR/${repo_slug}.zip"
      local archive_name="${repo##*/}-${branch}"

      curl -fsSL -o "$zip_file" "$archive_url"
      mkdir -p "$extract_dir"
      unzip -o -q "$zip_file" -d "$BUILD_DIR/temp_extract"
      mv "$BUILD_DIR/temp_extract/$archive_name"/* "$extract_dir/"
      rm -rf "$BUILD_DIR/temp_extract" "$zip_file"
    fi

    echo "$extract_dir"

  elif [[ "$url" =~ ^https?:// ]]; then
    local filename
    filename=$(basename "$url")
    local dest="$BUILD_DIR/urls/$filename"

    if [[ ! -f "$dest" ]]; then
      mkdir -p "$BUILD_DIR/urls"
      curl -fsSL -o "$dest" "$url"
    fi

    echo "$dest"

  else
    echo "$SCRIPT_NAME: fetch: unsupported URL scheme: $url" >&2
    return 1
  fi
}

# =============================================================================
# TOPIC DEFINITIONS
# =============================================================================

topic_gemini_api() {
  local repo
  repo=$(fetch "github://google-gemini/cookbook")

  # Notebooks - filter out binary image data with jq
  local nb
  for nb in "examples/Book_illustration.ipynb" "quickstarts/Image_out.ipynb"; do
    run "curl -s 'https://raw.githubusercontent.com/google-gemini/cookbook/main/$nb'" \
      "jq 'walk(if type == \"object\" and has(\"data\") and (.data | type == \"object\") then .data |= with_entries(select(.key | test(\"^image/\") | not)) else . end)' '$repo/$nb'"
  done

  # Documentation URLs
  local url
  for url in \
    "https://ai.google.dev/gemini-api/docs/image-generation.md.txt" \
    "https://ai.google.dev/gemini-api/docs/image-understanding.md.txt" \
    "https://ai.google.dev/gemini-api/docs/models.md.txt" \
    "https://ai.google.dev/gemini-api/docs/prompting-strategies.md.txt" \
    "https://ai.google.dev/gemini-api/docs/structured-output.md.txt" \
    "https://ai.google.dev/gemini-api/docs/text-generation.md.txt"
  do
    local file
    file=$(fetch "$url")
    run "curl -s '$url'" "cat '$file'"
  done
}

topic_gemini_sdk() {
  local repo
  repo=$(fetch "github://googleapis/js-genai")

  find "$repo/src" -type f | sort | while read -r file; do
    local rel="${file#$repo/}"
    run "curl -s 'https://raw.githubusercontent.com/googleapis/js-genai/main/$rel'" "cat '$file'"
  done
}

topic_mcp_server() {
  local repo
  repo=$(fetch "github://modelcontextprotocol/modelcontextprotocol")

  # Specific doc files
  local file
  for file in "docs/docs/learn/server-concepts.mdx" "docs/docs/learn/architecture.mdx"; do
    run "curl -s 'https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/main/$file'" "cat '$repo/$file'"
  done

  # Specification directory
  find "$repo/docs/specification/2025-11-25" -type f | sort | while read -r file; do
    local rel="${file#$repo/}"
    run "curl -s 'https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/main/$rel'" "cat '$file'"
  done
}

topic_mcp_typescript_sdk() {
  local repo
  repo=$(fetch "github://modelcontextprotocol/typescript-sdk")

  run "curl -s 'https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/main/README.md'" "cat '$repo/README.md'"
}

topic_gemini_cli() {
  local repo
  repo=$(fetch "github://google-gemini/gemini-cli")

  find "$repo/docs" -type f | sort | while read -r file; do
    local rel="${file#$repo/}"
    local published="https://geminicli.com/${rel%.md}/"
    run "curl -s 'https://raw.githubusercontent.com/google-gemini/gemini-cli/main/$rel'  # published to $published" "cat '$file'"
  done
}

topic_gemini_cli_extensions() {
  local repo
  repo=$(fetch "github://google-gemini/gemini-cli")

  find "$repo/docs/extensions" -name "*.md" -type f | sort | while read -r file; do
    local rel="${file#$repo/}"
    local published="https://geminicli.com/${rel%.md}/"
    run "curl -s 'https://raw.githubusercontent.com/google-gemini/gemini-cli/main/$rel'  # published to $published" "cat '$file'"
  done
}

topic_gemini_cli_hooks() {
  local repo
  repo=$(fetch "github://google-gemini/gemini-cli")

  find "$repo/docs/hooks" -name "*.md" -type f | sort | while read -r file; do
    local rel="${file#$repo/}"
    local published="https://geminicli.com/${rel%.md}/"
    run "curl -s 'https://raw.githubusercontent.com/google-gemini/gemini-cli/main/$rel'  # published to $published" "cat '$file'"
  done
}

topic_inkyframe() {
  local inky pico
  inky=$(fetch "github://pimoroni/inky-frame")
  pico=$(fetch "github://pimoroni/pimoroni-pico")

  # inky-frame docs, examples, modules
  local dir
  for dir in docs examples modules; do
    find "$inky/$dir" -type f 2>/dev/null | sort | while read -r file; do
      local rel="${file#$inky/}"
      run "curl -s 'https://raw.githubusercontent.com/pimoroni/inky-frame/main/$rel'" "cat '$file'"
    done
  done

  # pimoroni-pico picographics
  find "$pico/micropython/modules/picographics" -type f | sort | while read -r file; do
    local rel="${file#$pico/}"
    run "curl -s 'https://raw.githubusercontent.com/pimoroni/pimoroni-pico/main/$rel'" "cat '$file'"
  done

  # External URLs
  local mpremote
  mpremote=$(fetch "https://docs.micropython.org/en/latest/_sources/reference/mpremote.rst.txt")
  run "curl -s 'https://docs.micropython.org/en/latest/_sources/reference/mpremote.rst.txt'" "cat '$mpremote'"

  # Jina reader for learn.pimoroni.com
  local pimoroni_learn
  pimoroni_learn=$(fetch "https://r.jina.ai/https://learn.pimoroni.com/article/getting-started-with-inky-frame")
  run "curl -s 'https://learn.pimoroni.com/article/getting-started-with-inky-frame'" "cat '$pimoroni_learn'"
}

topic_rpi() {
  local repo
  repo=$(fetch "github://raspberrypi/documentation@master")

  local src="$repo/documentation/asciidoc/computers"

  local dir
  for dir in config_txt configuration getting-started os raspberry-pi remote-access; do
    # Index file
    if [[ -f "$src/$dir.adoc" ]]; then
      run "curl -s 'https://raw.githubusercontent.com/raspberrypi/documentation/master/documentation/asciidoc/computers/$dir.adoc'" "cat '$src/$dir.adoc'"
    fi
    # Directory contents
    if [[ -d "$src/$dir" ]]; then
      find "$src/$dir" -type f | sort | while read -r file; do
        local rel="${file#$repo/}"
        run "curl -s 'https://raw.githubusercontent.com/raspberrypi/documentation/master/$rel'" "cat '$file'"
      done
    fi
  done

  # Standalone file
  if [[ -f "$src/software-sources.adoc" ]]; then
    run "curl -s 'https://raw.githubusercontent.com/raspberrypi/documentation/master/documentation/asciidoc/computers/software-sources.adoc'" "cat '$src/software-sources.adoc'"
  fi
}

topic_skills() {
  # agentskills/agentskills repository - all .mdx files
  local agentskills
  agentskills=$(fetch "github://agentskills/agentskills")
  find "$agentskills" -name "*.mdx" -type f | sort | while read -r file; do
    local rel="${file#$agentskills/}"
    run "curl -s 'https://raw.githubusercontent.com/agentskills/agentskills/main/$rel'" "cat '$file'"
  done

  # Claude platform best practices
  local best_practices
  best_practices=$(fetch "https://platform.claude.com/docs/en/agents-and-tools/agent-skills/best-practices.md")
  run "curl -s 'https://platform.claude.com/docs/en/agents-and-tools/agent-skills/best-practices.md'" "cat '$best_practices'"

  # Anthropic skills repository
  local anthropic_skills
  anthropic_skills=$(fetch "https://raw.githubusercontent.com/anthropics/skills/refs/heads/main/skills/skill-creator/SKILL.md")
  run "curl -s 'https://raw.githubusercontent.com/anthropics/skills/refs/heads/main/skills/skill-creator/SKILL.md'" "cat '$anthropic_skills'"

  # Gemini CLI skills
  local gemini_skills
  gemini_skills=$(fetch "https://raw.githubusercontent.com/google-gemini/gemini-cli/main/docs/cli/skills.md")
  run "curl -s 'https://raw.githubusercontent.com/google-gemini/gemini-cli/main/docs/cli/skills.md'" "cat '$gemini_skills'"

  # OpenAI Codex skills
  local openai_skills
  openai_skills=$(fetch "https://developers.openai.com/codex/skills.md")
  run "curl -s 'https://developers.openai.com/codex/skills.md'" "cat '$openai_skills'"

  local openai_create
  openai_create=$(fetch "https://developers.openai.com/codex/skills/create-skill.md")
  run "curl -s 'https://developers.openai.com/codex/skills/create-skill.md'" "cat '$openai_create'"
}

# =============================================================================
# TOPIC REGISTRY
# =============================================================================

TOPICS=(
  "gemini-api:Gemini API documentation and examples"
  "gemini-sdk:Gemini TypeScript/JavaScript SDK"
  "mcp-server:MCP server documentation and specification"
  "mcp-typescript-sdk:MCP TypeScript SDK documentation"
  "gemini-cli:Gemini CLI documentation (all)"
  "gemini-cli-extensions:Gemini CLI extensions documentation"
  "gemini-cli-hooks:Gemini CLI hooks documentation"
  "inkyframe:Pimoroni Inky Frame documentation"
  "rpi:Raspberry Pi documentation"
  "skills:Agent skills documentation (Claude, Gemini CLI, OpenAI Codex)"
)

# =============================================================================
# USAGE AND ARGUMENT PARSING
# =============================================================================

usage() {
  cat <<EOF
Usage: $SCRIPT_NAME <topic>

Generate aggregated context for a specific topic. Output is written to stdout
as a shell_session XML format suitable for AI agent consumption.

Topics:
EOF
  for entry in "${TOPICS[@]}"; do
    local name="${entry%%:*}"
    local desc="${entry#*:}"
    printf "  %-22s %s\n" "$name" "$desc"
  done
  cat <<EOF

Options:
  -h, --help    Display this help message and exit
  --list        List available topics (names only)

Examples:
  $SCRIPT_NAME gemini-api
    Generate Gemini API context to stdout

  $SCRIPT_NAME gemini-api > gemini-api-context.xml
    Save context to a file

  $SCRIPT_NAME gemini-api | pbcopy
    Copy context to clipboard (macOS)
EOF
  exit 0
}

list_topics() {
  for entry in "${TOPICS[@]}"; do
    echo "${entry%%:*}"
  done
  exit 0
}

emit_header() {
  echo "<shell_session>"
  cat <<EOF
<context_summary>
  <purpose>
    This content represents a recorded shell session designed to provide context for an AI agent.
    It aggregates resources (local files, remote URLs, system info) by capturing shell commands
    and their output.
  </purpose>
  <structure>
    The session is organized as a sequence of &lt;entry&gt; elements:
    1. &lt;command&gt;: The command string acting as the data source. (e.g., "cat file.txt" or "curl url")
       Treat this as the source of truth for where the data originated.
    2. &lt;output&gt;: The raw content returned by that command.
    Errors appear as &lt;error&gt; elements with a &lt;message&gt; instead of &lt;output&gt;.
  </structure>
  <guidelines>
    - PROVENANCE: The origin of the data is defined by the command itself. If the command is
      \`curl -s https://example.com\`, the content is from that external URL.
    - SNAPSHOT: The outputs below capture the exact state of the resources at the time this script was run.
  </guidelines>
</context_summary>
EOF
}

emit_footer() {
  echo "</shell_session>"
}

# =============================================================================
# MAIN
# =============================================================================

if [[ $# -lt 1 ]]; then
  usage
fi

case "$1" in
  -h|--help)
    usage
    ;;
  --list)
    list_topics
    ;;
  -*)
    echo "$SCRIPT_NAME: unknown option: $1" >&2
    exit 1
    ;;
  *)
    TOPIC="$1"
    ;;
esac

# Validate topic
TOPIC_FUNC="topic_${TOPIC//-/_}"
if ! declare -f "$TOPIC_FUNC" > /dev/null 2>&1; then
  echo "$SCRIPT_NAME: unknown topic: $TOPIC" >&2
  echo "Run '$SCRIPT_NAME --list' to see available topics" >&2
  exit 1
fi

# Check dependencies
require curl
require unzip
require jq
require python3

# Create build directory
BUILD_DIR=$(mktemp -d "${TMPDIR:-/tmp}/$SCRIPT_NAME.XXXXXXXXXX")
trap 'rm -rf "$BUILD_DIR"' EXIT

# Output header
emit_header

# Run the topic function
"$TOPIC_FUNC"

# Output footer
emit_footer
