#!/usr/bin/env bash

usage() {
  cat <<EOF
Usage: $(basename "$0") [FILE...]

Format JSON files using jq.

When FILEs are provided, each file is formatted in place. When no FILE is
provided, reads from standard input and writes to standard output.

Arguments:
  FILE...     Paths to JSON files to format (optional)

Options:
  -h, --help  Display this help message and exit

Examples:

# Format a file in place

  $(basename "$0") config.json

# Format multiple files

  $(basename "$0") *.json

# Format from stdin to stdout

  curl -s <https://api.example.com/data> | $(basename "$0")

# Format a file and see the result

  $(basename "$0") < data.json
EOF
  exit 0
}

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  usage
fi

if [[ $# -eq 0 && -t 0 ]]; then
  usage
fi

# Determine which formatter to use

if ! command -v jq >/dev/null 2>&1; then
  echo "$(basename "$0"): jq not found" >&2
  exit 127
fi

FORMAT_CMD="jq ."

if [[ $# -eq 0 ]]; then

  # Read from stdin, write to stdout

  $FORMAT_CMD
else

  # Format files in place

  TMPFILE=$(mktemp)
  trap 'rm -f -- "$TMPFILE"' EXIT
  FAILED=0
  for FILE in "$@"; do
    if [[ ! -f "$FILE" ]]; then
      echo "$(basename "$0"): $FILE: No such file or directory" >&2
      FAILED=1
      continue
    fi
    if $FORMAT_CMD < "$FILE" > "$TMPFILE"; then
      cat "$TMPFILE" > "$FILE"
      echo "$(basename "$0"): $FILE: formatted"
    else
      echo "$(basename "$0"): $FILE: failed to format" >&2
      FAILED=1
    fi
  done
  exit $FAILED
fi
