#!/usr/bin/env bash

usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] 

Lists available activities on the connected device, tagged by category.

Supported categories:
  L - Launcher (android.intent.category.LAUNCHER)
  H - Home/Launcher App (android.intent.category.HOME)
  T - TV/Leanback (android.intent.category.LEANBACK_LAUNCHER)
  S - Settings (android.intent.category.PREFERENCE)

Options:
  --launcher-only  List only launcher activities
  --home-only      List only home/launcher app activities
  --tv-only        List only TV/Leanback activities
  --settings-only  List only settings activities
  -h, --help       Display this help message and exit

Environment:
  ANDROID_SERIAL  Serial number of device to connect to (see 'adb devices -l').
EOF
  exit 0
}

# Parse args
launcher_only=0
home_only=0
tv_only=0
settings_only=0

while [[ "$#" -gt 0 ]]; do
  case $1 in
    --launcher-only) launcher_only=1 ;;
    --home-only) home_only=1 ;;
    --tv-only) tv_only=1 ;;
    --settings-only) settings_only=1 ;;
    -h | --help) usage ;;
    *)
      echo "$(basename "$0"): unknown option '$1'" >&2
      exit 1
      ;;
  esac
  shift
done

# Validate mutual exclusivity (optional, but good for clarity if user expects combined list)
# Actually, allowing multiple flags to filter 'OR' logic or just failing?
# adb-tiles fails if both are set. Let's fail if more than one is set.
count=$((launcher_only + home_only + tv_only + settings_only))
if ((count > 1)); then
  echo "$(basename "$0"): cannot specify multiple *-only options" >&2
  exit 1
fi

require() { hash "$@" || exit 127; }

require adb

# Check device availability
if ! adb get-state >/dev/null 2>&1; then
  if [[ -n "$ANDROID_SERIAL" ]]; then
    echo "$(basename "$0"): device '$ANDROID_SERIAL' not available" >&2
  else
    echo "$(basename "$0"): no device connected" >&2
  fi
  exit 1
fi

# Define Intents
ACTION_MAIN="android.intent.action.MAIN"
CAT_LAUNCHER="android.intent.category.LAUNCHER"
CAT_HOME="android.intent.category.HOME"
CAT_LEANBACK="android.intent.category.LEANBACK_LAUNCHER"
CAT_PREFERENCE="android.intent.category.PREFERENCE"

# Awk script to parse 'cmd package query-activities' output
# ActivityInfo block structure is similar to ServiceInfo
# shellcheck disable=SC2016
PARSE_CMD_OUTPUT_AWK=' 
  /ActivityInfo:/ { in_block = 1; next }
  /ApplicationInfo:/ { in_block = 0; next }
  in_block && /name=/ { sub("name=", "", $1); name = $1 }
  in_block && /packageName=/ { sub("packageName=", "", $1); pkg = $1; print pkg "/" name }
'

# Queries
# We always query all 4 to build the complete list if no specific flag is set,
# or just the needed ones?
# Optimization: if a flag is set, only run that query.
# But for the "list all with tags" mode, we need all.

run_query() {
  local action=$1
  local cat=$2
  local args=("-c" "$cat")
  if [[ -n "$action" ]]; then
    args+=("-a" "$action")
  fi

  adb shell cmd package query-activities "${args[@]}" 2>/dev/null |
    awk "$PARSE_CMD_OUTPUT_AWK" |
    tr -d '\r'
}

# Fetch data
# We'll use associative arrays in the main awk to merge.

# If specific flag, just run one and exit
if ((launcher_only)); then
  run_query "$ACTION_MAIN" "$CAT_LAUNCHER" | sort | uniq
  exit 0
fi

if ((home_only)); then
  run_query "$ACTION_MAIN" "$CAT_HOME" | sort | uniq
  exit 0
fi

if ((tv_only)); then
  run_query "$ACTION_MAIN" "$CAT_LEANBACK" | sort | uniq
  exit 0
fi

if ((settings_only)); then
  run_query "" "$CAT_PREFERENCE" | sort | uniq
  exit 0
fi

# Default: List all with tags
# We fetch all concurrently (in background) or just sequentially?
# adb-tiles does it sequentially but feeds to awk via process substitution.

# Gather lists
list_l=$(run_query "$ACTION_MAIN" "$CAT_LAUNCHER")
list_h=$(run_query "$ACTION_MAIN" "$CAT_HOME")
list_t=$(run_query "$ACTION_MAIN" "$CAT_LEANBACK")
list_s=$(run_query "" "$CAT_PREFERENCE")

# Merge and Print
awk ' 
  function clean(c) { gsub(/^[ \t]+|[ \t]+$/, "", c); return c }

  { 
    type = $1
    $1 = ""
    comp = clean($0)
    if (comp == "") next
    
    if (type == "L:") l[comp] = 1
    else if (type == "H:") h[comp] = 1
    else if (type == "T:") t[comp] = 1
    else if (type == "S:") s[comp] = 1
  }

  END {
    for (c in l) all[c] = 1
    for (c in h) all[c] = 1
    for (c in t) all[c] = 1
    for (c in s) all[c] = 1

    for (c in all) {
      tag_l = (c in l) ? "L" : " "
      tag_h = (c in h) ? "H" : " "
      tag_t = (c in t) ? "T" : " "
      tag_s = (c in s) ? "S" : " "

      # Format: LH T S com.package/Activity
      printf "%s%s%s%s %s\n", tag_l, tag_h, tag_t, tag_s, c
    }
  }
' <(
  echo "$list_l" | awk '{print "L: " $0}'
  echo "$list_h" | awk '{print "H: " $0}'
  echo "$list_t" | awk '{print "T: " $0}'
  echo "$list_s" | awk '{print "S: " $0}'
) | sort | uniq
